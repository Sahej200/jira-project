{"expand": "renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations", "id": "13631230", "self": "https://issues.apache.org/jira/rest/api/2/issue/13631230", "key": "KAFKA-19779", "fields": {"summary": "Relax offset commit validation to allow member epochs since assignment", "description": "h2. Fencing offset commits\r\n\r\nIn the Kafka protocol, when a consumer commits offsets or a producer tries to add offsets to a transaction, it includes its epoch/generation of the consumer group. The point of this is for the group coordinator to fence against zombie commit requests, that is, commit requests that include an offset for a partition that was since reassigned to a different member. If such a guard was not in place, a zombie offset commit may overwrite offsets of the new owner, or its offsets may be committed to the consumer offset topic but not be included in the result of the new owners offset fetch request.\r\n\r\nIn KIP-848, when receiving an offset commit request that includes the client-side member epoch and a member ID, the group coordinator performs the check\r\n\r\n{{Client-Side Member Epoch == Broker-Side Member Epoch}}\r\n\r\nand, if the check fails, returns a {{STALE_MEMBER_EPOCH}} error for regular offset commits and a {{ILLEGAL_GENERATION}} for transactional offset commits. If the member epoch sent in the request is the current broker-side member epoch, KIP-848 guarantees that the partition cannot also be owned by a different member at the same or a larger epoch. Therefore, this is sufficient for fencing zombie commits. Note that we assume zombie commits will always contain offsets for partitions that were owned by the member at the member epoch sent in the request. Commit requests that commit offsets for partitions that are _not_ owned by the member in that epoch, are not possible in a correct client-side implementation of the protocol.\r\n\r\nNote that the broker-side member epoch is not the group epoch or the target assignment epoch. For details, see KIP-848. Note also that commits can also be fenced because a member falls out of the group (e.g. because it does not revoke partitions within the rebalance timeout). At this point, its commits will be fenced solely based on the member ID (which is not part of the group anymore). We therefore ignore this case in this document, and only consider zombie commits from members that are still part of the group.\r\nh2. Downsides of the current approach\r\n\r\nThis fencing is, however, unnecessarily strict. Assume, for example, a member owns P1 at epoch 1. The broker-side member epoch is bumped to 2, but the member still has P1 assigned at epoch 2. The member may not learn about the new broker-side member epoch in time, and submit an offset commit commit for P1 with epoch 1. This is not a zombie commit request as define above (because P1 was not reassigned to a different member), but it will still be rejected by a KIP-848 group coordinator.\r\n\r\nThe trouble with this fencing mechanism is that it is very difficult to avoid the broker-side member epoch being bumped concurrently with an offset commit. Seen from the client-side, the broker-side member epoch may be bumped at any time while a heartbeat to the group coordinator is in-flight. To make sure the member epoch sent in an offset commit request is up-to-date would require making sure that no consumer group or streams group heartbeat request is in-flight at the same time.\r\nh2. Why a broker-side fix is warranted\r\n\r\nThis problem is particularly challenging to solve on the client side for transactional offset commits, since they are performed by the producer, not the consumer, and the producer has no way of knowing when a consumer group heartbeat or streams group heartbeat is in-flight. The member epoch is passed from the Java consumer to the Java producer using the {{ConsumerGroupMetadata}} object, which is passed into {{{}sendOffsetsToTransaction{}}}. By the time the transactional offset commit is sent, the member epoch may be stale, the broker will return an {{ILLEGAL_GENERATION}} exception. This will force the Java producer into an abortable error state, surfacing the error as a {{CommitFailedException}} to the user, the user has no other way to recover from this to abort the transaction.\r\n\r\nThis may hurt in any Kafka client application, since aborting transactions means throwing away work and restarting from an earlier point. But it is a particularly big problem in Kafka Streams with exactly-once semantics, where aborting a transaction usually means wiping and restoring the state store, so each aborted transaction means some downtime for apps using state stores of non-negligible size. Furthermore, since Kafka Streams commits every 100ms by default in EOS, this is likely to happen fairly often.\r\nh1. Conceptual Design\r\n\r\nn this design document, we therefore propose to relax the condition for offset commit fencing.\r\nh2. Identifying zombies using the last epoch a partition was assigned to the member\r\n\r\nTo derive a more relaxed check, we need to identify an epoch which separates zombie commits from commits of the current owner. As mentioned above, zombie commit requests are commit requests that include a partition, member ID and member epoch combination, so that the member owned the partition at that epoch. However, the partition has since been reassigned to a different member.\r\n\r\nMost precisely, on the level of a single partition, a relaxed offset commit check can be defined using a *assignment epoch* for each assigned partition and each member, which is the epoch at which the partition was assigned to that member. To fence from zombie commit requests, we can reject all offset commit requests from a member that either does not have the partition assigned, or that includes any member epoch that is smaller or equal than the assignment epoch for that member and that partition.\r\n\r\nAssignment Epoch <= Client-Side Member Epoch <= Broker-Side Member Epoch\r\n\r\nThe correctness of this is obvious: all commits of the current partition owner will be accepted, since the Client-Side Member Epoch of the current owner must always have an epoch that is larger or equal than the assignment epoch (a partition that is revoked in one epoch is never reassigned in the same epoch). It will also correctly reject any zombie commits from that member, because if a partition was owned by the member A at Client-Side Member Epoch (which we assume for zombie commits), but it was reassigned to member B since, we have two possible cases:\r\n # Member A currently does not have the partition assigned\r\n\r\n # Member A does currently have the partition assigned, but then it must have been reassigned to member A after being assigned to member B. By KIP-848 this cannot all happen in the same epoch, so we must have Assignment Epoch > Client-Side Member Epoch.\r\n\r\nh3. Differences to the design above\r\n\r\nThis design does not need to disable commits on the client-side. The need to disable commits came from the fact that we are tracking epochs \u201cimprecisely\u201d, on the member-level and not on the partition-level. So in the RevocationEpoch design, when we have just revoked P2 on the client, we may attempt to commit a partition P1, triggering the race condition because the broker can concurrently bump the revocation epoch for that member because of the revocation of P2. We prevent this by disabling commits while a partition is revoked, and by \u201cwhile a partition is revoked\u201d I mean the timeframe from executing the revocation on the client, and seeing the following epoch bump on the client. In the partition-level AssignmentEpoch design, if we are committing P1, we are still convinced that we own P1, so we must also still own it on the broker. At the same time, we may remove the assignment epoch for P2 on the broker, but it doesn\u2019t matter since this doesn\u2019t impact whether we can commit P1, and we are not going to try to commit P2 after having revoked it on the client side.\r\nh1. Proposed Changes\r\nh3. Introducing Per-Member and Per-Partition Assignment Epoch\r\n\r\nWe extend the model of a consumer group / streams group member with one integer per assigned partition for each member of a group. This includes both partitions directly assigned to the member, and partitions pending revocation. The assignment epoch is set to the epoch in which the partition was assigned to the member, and we have the invariant Assignment Epoch <= MemberEpoch <= TargetAssignmentEpoch <= GroupEpoch.\r\n\r\nThe AssignmentEpoch is added as a field to TopicPartitions in ConsumerGroupCurrentMemberAssignmentValue, so that it can be stored and replayed from the committed offsets topic.\r\n\r\nFor streams groups, we will use the same logic but add assignment epochs only for active tasks in StreamsGroupCurrentMemberAssignmentValue, since only active tasks commit offsets in Kafka Streams.\r\nh3. Relaxing the offset commit validation\r\n\r\nWe replace the current check offset commit validation check\r\n\r\nClient-Side Member Epoch == Broker-Side Member Epoch\r\n\r\nby\r\n\r\nAssignment Epoch <= Client-Side Member Epoch <= Broker-Side Member Epoch\r\n\r\nwhere, for simplicity, we can assume the assignment epoch of a partition that is not assigned to that member to be Integer.maxValue.", "reporter": {"self": "https://issues.apache.org/jira/rest/api/2/user?username=lucasbru", "name": "lucasbru", "key": "JIRAUSER302322", "avatarUrls": {"48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=JIRAUSER302322&avatarId=53242", "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=JIRAUSER302322&avatarId=53242", "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=JIRAUSER302322&avatarId=53242", "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=JIRAUSER302322&avatarId=53242"}, "displayName": "Lucas Brutschy", "active": true, "timeZone": "Europe/Berlin"}, "comment": {"comments": [], "maxResults": 0, "total": 0, "startAt": 0}, "priority": {"self": "https://issues.apache.org/jira/rest/api/2/priority/3", "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg", "name": "Major", "id": "3"}, "status": {"self": "https://issues.apache.org/jira/rest/api/2/status/10002", "description": "A patch for this issue has been uploaded to JIRA by a contributor.", "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/document.png", "name": "Patch Available", "id": "10002", "statusCategory": {"self": "https://issues.apache.org/jira/rest/api/2/statuscategory/4", "id": 4, "key": "indeterminate", "colorName": "yellow", "name": "In Progress"}}}}