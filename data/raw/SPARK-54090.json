{"expand": "renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations", "id": "13632875", "self": "https://issues.apache.org/jira/rest/api/2/issue/13632875", "key": "SPARK-54090", "fields": {"summary": "AssertDataframeEqual carries rows when showing differences", "description": "When we try to do assertDataFrameEqual, on two dataframes that have not the same amount of rows, the output gets cascading from the difference till the end. Why this is happening:\r\n\r\n[https://github.com/apache/spark/blob/067969ff946712eeabf47040415f25000837cd87/python/pyspark/testing/utils.py#L1036]\r\n{code:java}\r\n\u00a0 \u00a0 def assert_rows_equal(\r\n\u00a0 \u00a0 \u00a0 \u00a0 rows1: List[Row], rows2: List[Row], maxErrors: int = None, showOnlyDiff: bool = False\r\n\u00a0 \u00a0 ):\r\n\u00a0 \u00a0 \u00a0 \u00a0 __tracebackhide__ = True\r\n\u00a0 \u00a0 \u00a0 \u00a0 zipped = list(zip_longest(rows1, rows2))\r\n\u00a0 \u00a0 \u00a0 \u00a0 diff_rows_cnt = 0\r\n\u00a0 \u00a0 \u00a0 \u00a0 diff_rows = []\r\n\u00a0 \u00a0 \u00a0 \u00a0 has_diff_rows = False\u00a0 \u00a0 \u00a0 \u00a0 \r\n        rows_str1 = \"\"\r\n\u00a0 \u00a0 \u00a0 \u00a0 rows_str2 = \"\"\u00a0 \u00a0 \u00a0 \u00a0 \r\n        \r\n        # count different rows\r\n\u00a0 \u00a0 \u00a0 \u00a0 for r1, r2 in zipped:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if not compare_rows(r1, r2):\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 diff_rows_cnt += 1\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 has_diff_rows = True\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if includeDiffRows:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 diff_rows.append((r1, r2))\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 rows_str1 += str(r1) + \"\\n\"\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 rows_str2 += str(r2) + \"\\n\"\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if maxErrors is not None and diff_rows_cnt >= maxErrors:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 elif not showOnlyDiff:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 rows_str1 += str(r1) + \"\\n\"\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 rows_str2 += str(r2) + \"\\n\"\u00a0 \u00a0 \u00a0 \u00a0 \r\n        generated_diff = _context_diff(\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 actual=rows_str1.splitlines(), expected=rows_str2.splitlines(), n=len(zipped)\r\n\u00a0 \u00a0 \u00a0 \u00a0 )\u00a0 \u00a0 \u00a0 \u00a0 \r\n        if has_diff_rows:\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 error_msg = \"Results do not match: \"\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 percent_diff = (diff_rows_cnt / len(zipped)) * 100\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 error_msg += \"( %.5f %% )\" % percent_diff\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 error_msg += \"\\n\" + \"\\n\".join(generated_diff)\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 data = diff_rows if includeDiffRows else None\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 raise PySparkAssertionError(\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 errorClass=\"DIFFERENT_ROWS\", messageParameters={\"error_msg\": error_msg}, data=data\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ){code}\r\nThe problem lies in the way that we zip the lines\r\n{code:java}\r\nzipped = list(zip_longest(rows1, rows2)){code}\r\nWith zip longest we assume that the rows are in order and we do position by position comparison but it does not work well with checkRowOrder which defaults to False.\r\n\r\nIf I have 1 line difference in 100 line dataframe the result percentage won't be 1% but the amount of rows that cascade towards on from that difference.\u00a0\r\n\r\nThe best solution here would be to have a set based comparison and return the percentage and the rows over that.\r\n\r\nA sample of what zip_longest is doing:\r\n{code:java}\r\nfrom itertools import zip_longest\r\nrows1 = [    'A',    'B',    'C',    'D',    'E']\r\nrows2 = [    'A',    'C',    'D',]\r\nzipped = list(zip_longest(rows1, rows2))zipped {code}\r\nResult:\r\n{code:java}\r\n[('A', 'A'), ('B', 'C'), ('C', 'D'), ('D', None), ('E', None)]{code}\r\nSo in this case we would have 80% rows failure.\r\n\r\nThis comes directly with the implementation of CheckRowOrder, when it is True we do not sort and it makes sense to use the zip_longest, when it is False it makes sense to use set based comparison since we have already sorted.\r\n\r\n\u00a0", "reporter": {"self": "https://issues.apache.org/jira/rest/api/2/user?username=aimtsou", "name": "aimtsou", "key": "JIRAUSER299048", "avatarUrls": {"48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452", "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452", "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452", "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"}, "displayName": "Aimilios Tsouvelekakis", "active": true, "timeZone": "Etc/UTC"}, "comment": {"comments": [], "maxResults": 0, "total": 0, "startAt": 0}, "priority": {"self": "https://issues.apache.org/jira/rest/api/2/priority/3", "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg", "name": "Major", "id": "3"}, "status": {"self": "https://issues.apache.org/jira/rest/api/2/status/1", "description": "The issue is open and ready for the assignee to start work on it.", "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png", "name": "Open", "id": "1", "statusCategory": {"self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2", "id": 2, "key": "new", "colorName": "blue-gray", "name": "To Do"}}}}