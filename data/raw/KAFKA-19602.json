{"expand": "renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations", "id": "13626245", "self": "https://issues.apache.org/jira/rest/api/2/issue/13626245", "key": "KAFKA-19602", "fields": {"summary": "Kafka Streams join after unmaterialized transformValues on KTable with extra store fails", "description": "I believe for this to occur you need\r\n # transformValues on a KTable, followed by a KTable join or leftJoin\r\n # The transformValues is not materialized (no store name given)\r\n # The transformValues accesses at least one extra store\r\n\r\nTested on 3.6.1 and 3.9.1\r\n\r\nExample code:\r\n{code:java}\r\n@Component\r\nclass TestCase {\r\n    private static final StoreBuilder<TimestampedKeyValueStore<String, String>> TRANSFORMER_STORE =\r\n          Stores.timestampedKeyValueStoreBuilder(\r\n                Stores.persistentTimestampedKeyValueStore(\"transformer-store\"),\r\n                Serdes.String(),\r\n                Serdes.String()\r\n          );\r\n\r\n    private final StreamsBuilder streamsBuilder;\r\n\r\n    TestCase(StreamsBuilder streamsBuilder) {\r\n       this.streamsBuilder = streamsBuilder;\r\n    }\r\n\r\n    @PostConstruct\r\n    void configure() {\r\n       streamsBuilder.addStateStore(TRANSFORMER_STORE);\r\n\r\n       var aggregateTable = streamsBuilder\r\n             .stream(\"input\", Consumed.with(Serdes.String(), Serdes.String()).withName(\"input-to-stream\"))\r\n             .toTable(Named.as(\"to-table\"), MaterializedAs.keyValue(\"aggregate-store\",\r\n                   Serdes.String(), Serdes.String()))\r\n             .transformValues(MyTransformer::new,\r\n                   Materialized.with(Serdes.String(), Serdes.String()),\r\n                   Named.as(\"my-transformer\"), TRANSFORMER_STORE.name());\r\n\r\n       aggregateTable\r\n             .join(aggregateTable,\r\n                   (value, _) -> value,\r\n                   Named.as(\"after-transformer\"),\r\n                   Materialized.<String, String, KeyValueStore<Bytes, byte[]>>as(\"after-transformer-store\")\r\n                         .withKeySerde(Serdes.String())\r\n                         .withValueSerde(Serdes.String()))\r\n             .toStream(Named.as(\"aggregate-to-stream\"))\r\n             .to(\"output\", Produced.with(Serdes.String(), Serdes.String()).withName(\"output-to-topic\"));\r\n\r\n       System.out.println(streamsBuilder.build().describe().toString());\r\n    }\r\n\r\n    private static class MyTransformer implements ValueTransformerWithKey<String, String , String> {\r\n       @Override\r\n       public void init(ProcessorContext context) {\r\n          context.getStateStore(TRANSFORMER_STORE.name());\r\n       }\r\n\r\n       @Override\r\n       public String transform(String readOnlyKey, String value) {\r\n          return value;\r\n       }\r\n\r\n       @Override\r\n       public void close() {\r\n       }\r\n    }\r\n}\r\n {code}\r\nResult of the above code:\r\n\r\n\u00a0\r\n{noformat}\r\norg.apache.kafka.streams.errors.StreamsException: failed to initialize processor after-transformer-join-this\r\n\u00a0 \u00a0 at org.apache.kafka.streams.processor.internals.ProcessorNode.init(ProcessorNode.java:131) ~[kafka-streams-3.9.1.jar:na]\r\n\u00a0 \u00a0 at org.apache.kafka.streams.processor.internals.ProcessorNode.init(ProcessorNode.java:140) ~[kafka-streams-3.9.1.jar:na]\r\n\u00a0 \u00a0 at org.apache.kafka.streams.processor.internals.StreamTask.initializeTopology(StreamTask.java:1089) ~[kafka-streams-3.9.1.jar:na]\r\n\u00a0 \u00a0 at org.apache.kafka.streams.processor.internals.StreamTask.completeRestoration(StreamTask.java:295) ~[kafka-streams-3.9.1.jar:na]\r\n\u00a0 \u00a0 at org.apache.kafka.streams.processor.internals.TaskManager.transitRestoredTaskToRunning(TaskManager.java:980) ~[kafka-streams-3.9.1.jar:na]\r\n\u00a0 \u00a0 at org.apache.kafka.streams.processor.internals.TaskManager.handleRestoredTasksFromStateUpdater(TaskManager.java:1055) ~[kafka-streams-3.9.1.jar:na]\r\n\u00a0 \u00a0 at org.apache.kafka.streams.processor.internals.TaskManager.checkStateUpdater(TaskManager.java:920) ~[kafka-streams-3.9.1.jar:na]\r\n\u00a0 \u00a0 at org.apache.kafka.streams.processor.internals.StreamThread.checkStateUpdater(StreamThread.java:1191) ~[kafka-streams-3.9.1.jar:na]\r\n\u00a0 \u00a0 at org.apache.kafka.streams.processor.internals.StreamThread.runOnceWithoutProcessingThreads(StreamThread.java:999) ~[kafka-streams-3.9.1.jar:na]\r\n\u00a0 \u00a0 at org.apache.kafka.streams.processor.internals.StreamThread.runLoop(StreamThread.java:713) ~[kafka-streams-3.9.1.jar:na]\r\n\u00a0 \u00a0 at org.apache.kafka.streams.processor.internals.StreamThread.run(StreamThread.java:672) ~[kafka-streams-3.9.1.jar:na]\r\nCaused by: org.apache.kafka.streams.errors.StreamsException: Processor after-transformer-join-this has no access to StateStore transformer-store as the store is not connected to the processor. If you add stores manually via '.addStateStore()' make sure to connect the added store to the processor by providing the processor name to '.addStateStore()' or connect them via '.connectProcessorAndStateStores()'. DSL users need to provide the store name to '.process()', '.transform()', or '.transformValues()' to connect the store to the corresponding operator, or they can provide a StoreBuilder by implementing the stores() method on the Supplier itself. If you do not add stores manually, please file a bug report at https://issues.apache.org/jira/projects/KAFKA.\r\n\u00a0 \u00a0 at org.apache.kafka.streams.processor.internals.ProcessorContextImpl.getStateStore(ProcessorContextImpl.java:174) ~[kafka-streams-3.9.1.jar:na]\r\n\u00a0 \u00a0 at org.apache.kafka.streams.processor.internals.ForwardingDisabledProcessorContext.getStateStore(ForwardingDisabledProcessorContext.java:90) ~[kafka-streams-3.9.1.jar:na]\r\n\u00a0 \u00a0 at be.florens.kafkaspringtest.selfjoin.TestCase$MyTransformer.init(TestCase.java:63) ~[main/:na]\r\n\u00a0 \u00a0 at org.apache.kafka.streams.kstream.internals.KTableTransformValues$KTableTransformValuesGetter.init(KTableTransformValues.java:156) ~[kafka-streams-3.9.1.jar:na]\r\n\u00a0 \u00a0 at org.apache.kafka.streams.kstream.internals.KTableKTableInnerJoin$KTableKTableJoinProcessor.init(KTableKTableInnerJoin.java:83) ~[kafka-streams-3.9.1.jar:na]\r\n\u00a0 \u00a0 at org.apache.kafka.streams.processor.internals.ProcessorNode.init(ProcessorNode.java:123) ~[kafka-streams-3.9.1.jar:na]\r\n\u00a0 \u00a0 ... 10 common frames omitted{noformat}\r\n\u00a0\r\n\r\n\u00a0", "reporter": {"self": "https://issues.apache.org/jira/rest/api/2/user?username=florens", "name": "florens", "key": "JIRAUSER310711", "avatarUrls": {"48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044", "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044", "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044", "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"}, "displayName": "Florens Pauwels", "active": true, "timeZone": "Etc/UTC"}, "comment": {"comments": [], "maxResults": 0, "total": 0, "startAt": 0}, "priority": {"self": "https://issues.apache.org/jira/rest/api/2/priority/4", "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg", "name": "Minor", "id": "4"}, "status": {"self": "https://issues.apache.org/jira/rest/api/2/status/1", "description": "The issue is open and ready for the assignee to start work on it.", "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png", "name": "Open", "id": "1", "statusCategory": {"self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2", "id": 2, "key": "new", "colorName": "blue-gray", "name": "To Do"}}}}